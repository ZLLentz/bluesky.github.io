

<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>Annotating Bluesky Plans &mdash; bluesky-queueserver 0.post1+g51785fe documentation</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/theme_overrides.css" type="text/css" />

  
  

  
  

  

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="bluesky_queueserver.parameter_annotation_decorator" href="generated/bluesky_queueserver.parameter_annotation_decorator.html" />
    <link rel="prev" title="bluesky_queueserver.validate_plan" href="generated/bluesky_queueserver.validate_plan.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> bluesky-queueserver
          

          
          </a>

          
            
            
              <div class="version">
                0.post1+g51785fe
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial (Demo)</a></li>
<li class="toctree-l1"><a class="reference internal" href="release_history.html">Release History</a></li>
</ul>
<p class="caption"><span class="caption-text">User's Guide</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="introduction_for_users.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="workflow.html">Submitting and Managing Plans</a></li>
<li class="toctree-l1"><a class="reference internal" href="startup_code.html">Organizing Bluesky Startup Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="ipython.html">Using IPython Startup Files</a></li>
<li class="toctree-l1"><a class="reference internal" href="plan_validation.html">Plan Validation</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Annotating Bluesky Plans</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#introduction">Introduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="#plans-without-annotation-default-rules">Plans Without Annotation (Default Rules)</a></li>
<li class="toctree-l2"><a class="reference internal" href="#supported-types">Supported Types</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-types-in-plan-header">Defining Types in Plan Header</a></li>
<li class="toctree-l2"><a class="reference internal" href="#defining-default-values-in-plan-header">Defining Default Values in Plan Header</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parameter-descriptions-in-docstring">Parameter Descriptions in Docstring</a></li>
<li class="toctree-l2"><a class="reference internal" href="#parameter-annotation-decorator">Parameter Annotation Decorator</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#plan-and-parameter-descriptions">Plan and Parameter Descriptions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameter-types">Parameter Types</a></li>
<li class="toctree-l3"><a class="reference internal" href="#default-values">Default Values</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#plan-annotation-api">Plan Annotation API</a><ul>
<li class="toctree-l3"><a class="reference internal" href="generated/bluesky_queueserver.parameter_annotation_decorator.html">bluesky_queueserver.parameter_annotation_decorator</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="cli_tools.html">Command-Line Tools</a></li>
</ul>
<p class="caption"><span class="caption-text">Application Developer's Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="interacting_with_qs.html">Interacting with Queue Server</a></li>
<li class="toctree-l1"><a class="reference internal" href="re_manager_api.html">Run Engine Manager API</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">bluesky-queueserver</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
      <li>Annotating Bluesky Plans</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/plan_annotation.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="annotating-bluesky-plans">
<h1>Annotating Bluesky Plans<a class="headerlink" href="#annotating-bluesky-plans" title="Permalink to this headline">¶</a></h1>
<div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>Before plans could be submitted to the queue, the startup scripts must be processed
by Queue Server. Processing involves loading the scripts in the RE Worker namespace,
identifying devices and plans in the namespace, generating representation of plans
and devices and saving the representations to the <code class="docutils literal notranslate"><span class="pre">existing_plans_and_devices.yaml</span></code>
file. The file is created by manually running <code class="docutils literal notranslate"><span class="pre">qserver-list-plans-devices</span></code> CLI tool
(see <a class="reference internal" href="cli_tools.html#qserver-list-plans-devices-cli"><span class="std std-ref">qserver-list-plans-devices</span></a>).</p>
<p>Representations of plans generated by <code class="docutils literal notranslate"><span class="pre">qserver-list-plans-devices</span></code> contain parameters
such as text descriptions of plans and plan parameters, parameter type annotations and
default values. The representations are sufficient to perform validation of parameters
of submitted plans without access to startup scripts or RE Worker namespace. Plan
representations can also be downloaded by the client applications
(<a class="reference internal" href="re_manager_api.html#method-plans-allowed"><span class="std std-ref">‘plans_allowed’</span></a> 0MQ API) and used to validate plan parameters before
the plans are submitted to the server. For details on plan parameter validation see
(<a class="reference internal" href="plan_validation.html#id1"><span class="std std-ref">Plan Validation</span></a>).</p>
<p>Client application may also use data such as text descriptions, type annotations and
default values that are contained plan representations for generating or annotating user
interfaces (e.g. GUI forms for plan parameters).</p>
<p>In this manual, the elements of a plan (Python function) header, docstring and
the parameters of the optional <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> that are used
for generating plan representations are referred as <strong>plan annotation</strong>.</p>
<p>All elements in plan annotations are optional. But properly annotating plans may be
useful if features such as parameter validation or automated user interface generation
are needed. Plan parameter validation is especially useful when plan parameters are
manually entered by the user, because it allows to detect invalid parameter types
and values at the time when plans are submitted to the queue (plans are rejected)
as opposed to having plans fail during execution (plans can still fail even if
the parameter validation is successful).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Validation of plan parameters is performed each time a new or modified plan is
submitted to Queue Server. Validation can be also performed on the client side
before the plan is submitted. To run validation the client must download
the lists of allowed plans and devices  (<a class="reference internal" href="re_manager_api.html#method-plans-allowed"><span class="std std-ref">‘plans_allowed’</span></a> and
<cite>:ref:`method_devices_allowed</cite> 0MQ API) and call <cite>validate_plan()</cite>
(<a class="reference internal" href="plan_validation.html#plan-validation-api"><span class="std std-ref">API for Plan Validation</span></a>).</p>
</div>
<p>Plan annotation may contain the following (optional) elements:</p>
<ul class="simple">
<li><p><strong>Description of the plan</strong>: multiline text that describes the plan.
The plan description may be displayed to users by client applications.</p></li>
<li><p><strong>Descriptions for each parameter of the plan</strong>: multiline text that describes
a plan parameter. Separate description is provided for each parameter.
Parameter descriptions may be displayed to users by client applications.</p></li>
<li><p><strong>Type annotations for each parameter</strong>. Parameter types are used
for validation of plan parameters. The types may also be used by client applications
for generating user interfaces.</p></li>
<li><p><strong>Default values for each parameter</strong>. The parameters with defined default values
are optional (following Python rules). The default values are used
for parameter validation. The default values may also be used by client applications
for generating user interfaces.</p></li>
</ul>
<p>The elements of plan annotations are defined in the plan header (type hints and
default values) and the docstring (parameter descriptions). In addition, Queue Server
provides <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> (<a class="reference internal" href="#parameter-annotation-decorator"><span class="std std-ref">Parameter Annotation Decorator</span></a>),
which allows to define or override any annotation item. The decorator is optional
and should be used only when necessary.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>When a plan is executed in IPython environment, it behaves as a regular Python
generator function. Only the default values defined in the plan header are used.
Any elements defined in <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> are ignored.</p>
</div>
</div>
<div class="section" id="plans-without-annotation-default-rules">
<span id="plans-without-annotation"></span><h2>Plans Without Annotation (Default Rules)<a class="headerlink" href="#plans-without-annotation-default-rules" title="Permalink to this headline">¶</a></h2>
<p>All elements of arameter annotations are optional. Plans without annotations can be
successfully managed by Queue Server. The text descriptions of plans and plan
parameters are intended for use by client applications and have no influence on
Queue Server operation.</p>
<p>Parameter types and default values are used for plan parameter validation. The parameters
with defined default values are <strong>optional</strong>. Values for the <strong>required</strong> parameters
(without default values) must be specified when plans are submitted to the queue.</p>
<p>For each parameter with specified type annotation, parameter validation includes
checking the type of the submitted parameter value. The parameters with no type
annotation are treated according to the default rules:</p>
<ul class="simple">
<li><p>type checking always succeeds, i.e. any submitted value is accepted
and passed to the plan (the plan execution may fail due to incorrect parameter type).</p></li>
<li><p>the parameter values parsed and all detected strings that are matching names of
objects (plans or devices) in the RE Worker namespace are replaced with references
to the objects (see details below).</p></li>
</ul>
<p>The validation algorithm is processing annotations for each parameter independently.
The parameters with defined types are subjected to type checking, while the parameters
with no type annotations are processed using the default rules.</p>
<p>The examples of the plans with no annotation:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plan_demo1a</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">delay</span><span class="p">):</span>
    <span class="c1"># Parameters &#39;npts&#39; and &#39;delay&#39; accept values of any type.</span>
    <span class="c1">#   No validation of parameter value types will be performed</span>
    <span class="c1">#   before execution of the plan is started. The plan will probably</span>
    <span class="c1">#   fail if parameters are of incorrect type.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>

<span class="k">def</span> <span class="nf">plan_demo1b</span><span class="p">(</span><span class="n">npts</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="c1"># Same as &#39;plan_demo1&#39; except the default value for parameter &#39;delay&#39; is</span>
    <span class="c1">#   specified, which makes the parameter &#39;delay&#39; optional.</span>
    <span class="c1">#   No type validation is performed for any parameter.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Queue Server supports plans that are accepting references to devices or other plans.
The devices or plans passed as parameters must be defined in startup scripts and
loaded in RE Worker namespace and represented in <code class="docutils literal notranslate"><span class="pre">existing_plans_and_devices.yaml</span></code>.
When plan parameters are submitted Queue Server, the devices and plans must
be represented by their names (type <code class="docutils literal notranslate"><span class="pre">str</span></code>). The names are replaced by
references to objects in RE Worker namespace before the parameters are passed to the plan
for execution. Submitted parameter values are parsed and each strings found in the tree
formed by lists, tuples and dictionaries is replaced with a reference to an objects with
the matching name. If there is no object with the name matching the string or the name
is not in the list of allowed plans or allowed devices for the user submitting the plan,
then the string is not modified. Dictionary keys are never modified.</p>
<p>The operation of replacing plan and device names with references to objects from RE Worker
namespace is performed for each parameter with no type annotation. This means that
every string that matches a name of a device or a plan from the list of allowed
devices or the list of allowed plans is replaced by the reference to the respective object
from RE Worker namespace.</p>
<p>Let’s consider an example of a plan with parameter <code class="docutils literal notranslate"><span class="pre">detectors</span></code> that is expected to
receive a list of detectors:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span>
<span class="c1"># Assume that the detectors &#39;det1&#39;, &#39;det2&#39;, &#39;det3&#39; are included in the list</span>
<span class="c1">#   of allowed devices for the user submitting the plan.</span>

<span class="k">def</span> <span class="nf">plan_demo1c</span><span class="p">(</span><span class="n">detectors</span><span class="p">,</span> <span class="n">npts</span><span class="p">):</span>
    <span class="c1"># The parameter &#39;detectors&#39; is expected to receive a list of detectors.</span>
    <span class="c1"># There is no type annotation, so the type is not validated.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>If the plan parameters submitted to the queue contain <code class="docutils literal notranslate"><span class="pre">&quot;detectors&quot;:</span> <span class="pre">[&quot;det1&quot;,</span> <span class="pre">&quot;det3&quot;]</span></code>,
then the strings <code class="docutils literal notranslate"><span class="pre">&quot;det1&quot;</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;det3&quot;</span></code> are replaced with references to objects
<code class="docutils literal notranslate"><span class="pre">det1</span></code> and <code class="docutils literal notranslate"><span class="pre">det3</span></code> and the plan is executed as if it was called from IPython
using</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">RE</span><span class="p">(</span><span class="n">plan_demo1c</span><span class="p">([</span><span class="n">det1</span><span class="p">,</span> <span class="n">det3</span><span class="p">],</span> <span class="o">&lt;</span><span class="n">value</span> <span class="n">of</span> <span class="n">npts</span><span class="o">&gt;</span><span class="p">))</span>
</pre></div>
</div>
<p>Blindly attempting to convert all strings in the passed parameter to references
works well in most of the simple cases, unless the workflow requires to pass strings
that are names of existing objects without converting them to references. If automated
conversion is causing issues, it can be disabled for any given parameter by
specifying the parameter type (e.g. using type hints in the plan header).
For example, one may need to pass plan or device names to the plan:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span>
<span class="c1"># Assume that the detectors &#39;det1&#39;, &#39;det2&#39;, &#39;det3&#39; are in the list</span>
<span class="c1">#   of allowed devices for the user submitting the plan.</span>

<span class="k">def</span> <span class="nf">plan_demo1d</span><span class="p">(</span><span class="n">detector_names</span><span class="p">,</span> <span class="n">npts</span><span class="p">):</span>
    <span class="c1"># The parameter &#39;detector_names&#39; is expected to receive a list of detector names.</span>
    <span class="c1">#   DOES NOT WORK: references to objects will be passed</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>

<span class="k">def</span> <span class="nf">plan_demo1e</span><span class="p">(</span><span class="n">detector_names</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">npts</span><span class="p">):</span>
    <span class="c1"># The parameter &#39;detector_names&#39; is expected to receive a list of detector names.</span>
    <span class="c1">#   WORKS !!!</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>If the value <code class="docutils literal notranslate"><span class="pre">&quot;detector_names&quot;:</span> <span class="pre">[&quot;det1&quot;,</span> <span class="pre">&quot;det3&quot;]</span></code> is passed to the plan <code class="docutils literal notranslate"><span class="pre">plan_demo1d`,</span>
<span class="pre">then</span> <span class="pre">the</span> <span class="pre">detector</span> <span class="pre">names</span> <span class="pre">are</span> <span class="pre">converted</span> <span class="pre">to</span> <span class="pre">references.</span> <span class="pre">Adding</span> <span class="pre">type</span> <span class="pre">hint</span> <span class="pre">for</span> <span class="pre">the</span> <span class="pre">parameter</span>
<span class="pre">``detector_names</span></code> (see <code class="docutils literal notranslate"><span class="pre">plan_demo1e</span></code>) disables string conversion and names are passed
to the plan unchanged. Adding type hint also enables type validation for parameter
<code class="docutils literal notranslate"><span class="pre">detector_names</span></code> and the plan is going to be rejected by Queue Server if the submitted
value is not a list of strings. Type hint may be as restrictive as needed. For example,
type hint <code class="docutils literal notranslate"><span class="pre">typing.Any</span></code> will still disable conversion of strings, but the server will accept
value of any type.</p>
<p>The operation of string conversion always succeeds. If the device name is incorrectly spelled
or not in the list of allowed plans or devices, then name remains a string and is passed
to the plan unchanged. For example, assume that <code class="docutils literal notranslate"><span class="pre">&quot;detectors&quot;:</span> <span class="pre">[&quot;det1&quot;,</span> <span class="pre">&quot;det4&quot;]</span></code> is passed to
<code class="docutils literal notranslate"><span class="pre">plan_demo1c</span></code>. There is no device named <code class="docutils literal notranslate"><span class="pre">det4</span></code> in the RE Worker namespace, so it will
not be converted to reference. As a result, the <code class="docutils literal notranslate"><span class="pre">detectors</span></code> parameter will receive a list
<code class="docutils literal notranslate"><span class="pre">[det1,</span> <span class="pre">&quot;det4&quot;]</span></code> and the plan will fail during execution. Queue Server provides
<code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> (<a class="reference internal" href="#parameter-annotation-decorator"><span class="std std-ref">Parameter Annotation Decorator</span></a>), which can be
used to define types for advanced parameter validation. In particular, the decorator
allows to define custom enums based on lists of device or plan names that could be used
to restrict object names that that could be passed to the parameter. Specifying lists
of plans or devices enables the string conversion, but only the listed names will
be converted to references.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span>
<span class="c1"># Assume that the detectors &#39;det1&#39;, &#39;det2&#39;, &#39;det3&#39; are in the list</span>
<span class="c1">#   of allowed devices for the user submitting the plan.</span>

<span class="kn">from</span> <span class="nn">bluesky_queueserver</span> <span class="kn">import</span> <span class="n">parameter_annotation_decorator</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;detectors&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;typing.List[DevicesType1]&quot;</span><span class="p">,</span>
            <span class="s2">&quot;devices&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;DevicesType1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det2&quot;</span><span class="p">,</span> <span class="s2">&quot;det3&quot;</span><span class="p">]}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo1f</span><span class="p">(</span><span class="n">detectors</span><span class="p">,</span> <span class="n">npts</span><span class="p">):</span>
    <span class="c1"># The parameter &#39;detector_names&#39; is expected to receive a list of detector names.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The type annotation in the decorator overrides the type annotation in the function header.
Only the lists of device names from the predefined set are accepted by the server.
If the submitted plan contains <code class="docutils literal notranslate"><span class="pre">&quot;detectors&quot;:</span> <span class="pre">[&quot;det1&quot;,</span> <span class="pre">&quot;det4&quot;]</span></code>, then the plan is rejected.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Value of any type that is serializable to JSON can be passed to the plan if
the respective parameter type is not defined or defined as <code class="docutils literal notranslate"><span class="pre">typing.Any</span></code>.
In the latter case the server does not attempt to convert strings to references
to objects.</p>
</div>
</div>
<div class="section" id="supported-types">
<span id="id1"></span><h2>Supported Types<a class="headerlink" href="#supported-types" title="Permalink to this headline">¶</a></h2>
<p>Queue Server puts restrictions on types used for type annotations and default values. If a plan header
contains parameter type annotation that is not supported, Queue Server ignores the annotation
and the plan is processed as if the parameter contained no annotation. If unsupported type annotation
is defined in <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code>, then processing of the plan fails and plan
representation for <code class="docutils literal notranslate"><span class="pre">existing_plans_and_devices.yaml</span></code> can not be generated.
Processing also fails if the default value defined in the plan header or in the decorator has
unsupported type.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Type annotations and default values defined in <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> override type
annotations and default values defined in the plan header. If type or default value is defined
in the decorator, the respective type and default value from the header are not analyzed.
If it is unavoidable that the plan must have unsupported type annotation or default value
in the header, then the <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> should be used to override
the type or default value in order for the plan processing to work.</p>
</div>
<p><strong>Supported types for type annotations.</strong> Type annotations may be native Python types
(such as <code class="docutils literal notranslate"><span class="pre">int</span></code>, <code class="docutils literal notranslate"><span class="pre">float</span></code>, <code class="docutils literal notranslate"><span class="pre">str</span></code>, etc.), <code class="docutils literal notranslate"><span class="pre">NoneType</span></code>, or generic types that are based
on native Python types (<code class="docutils literal notranslate"><span class="pre">typing.List[typing.Union[int,</span> <span class="pre">str]]</span></code>). Technically the type will
be accepted if the operation of creating the type object from its string representation
using <code class="docutils literal notranslate"><span class="pre">eval</span></code> function and the namespace that contains imported <code class="docutils literal notranslate"><span class="pre">typing</span></code> module and
<code class="docutils literal notranslate"><span class="pre">NoneType</span></code> type should be successful.</p>
<p><strong>Supported types of default values.</strong> The default values can be objects of native Python
types and literal expressions with objects of native Python types. The default value should
be reconstructable with function <code class="docutils literal notranslate"><span class="pre">ast.literal_eval</span></code>, i.e. for the default value <code class="docutils literal notranslate"><span class="pre">vdefault</span></code>,
the operation <code class="docutils literal notranslate"><span class="pre">ast.literal_eval(f&quot;{vdefault!r}&quot;)</span></code> should complete successfully.</p>
<p>The following is an example of a plan with type annotation that is not be accepted
by Queue Server. The type annotation is defined in the plan header,  so it is ignored
and no type annotation is included in the plan representation for the parameter <code class="docutils literal notranslate"><span class="pre">detector</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd</span> <span class="kn">import</span> <span class="n">Device</span>

<span class="k">def</span> <span class="nf">plan_demo2a</span><span class="p">(</span><span class="n">detector</span><span class="p">:</span> <span class="n">Device</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="c1"># Type &#39;Device&#39; is not recognized by Queue Server, because it needs to be imported</span>
    <span class="c1">#   from Ophyd. Type annotation will be ignored by Queue Server.</span>
    <span class="c1">#   Use &#39;parameter_annotation_decorator&#39; to override annotation for</span>
    <span class="c1">#   &#39;detector&#39; of type annotation is required.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>In the following example, the type of the default value of the <code class="docutils literal notranslate"><span class="pre">detector</span></code> parameter is not
supported and processing of the plan fails. The issue can be fixed by overriding the default value
using <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> (<a class="reference internal" href="#parameter-annotation-decorator"><span class="std std-ref">Parameter Annotation Decorator</span></a>).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span>

<span class="k">def</span> <span class="nf">plan_demo2b</span><span class="p">(</span><span class="n">detector</span><span class="o">=</span><span class="n">det1</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="c1"># Default value &#39;det1&#39; can not be used with the Queue Server.</span>
    <span class="c1">#   Fix: use &#39;parameter annotation decorator to override the default value.</span>
   <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="defining-types-in-plan-header">
<h2>Defining Types in Plan Header<a class="headerlink" href="#defining-types-in-plan-header" title="Permalink to this headline">¶</a></h2>
<p>As part of processing plans from RE Worker namespace, Queue Server is analyzing
plan signatures. If a plan signature contains type hints, the types are validated, and their string
representation is saved. Type hints that fail validation are ignored and Queue Server assumes
that the parameter has not type annotation.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Queue Server ignores type hints defined in the plan signature for parameters that have
type annotations defined in <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code>.</p>
</div>
<p>The acceptable types include Python base types, <code class="docutils literal notranslate"><span class="pre">NoneType</span></code> and imports from <code class="docutils literal notranslate"><span class="pre">typing</span></code> module
(see <a class="reference internal" href="#supported-types"><span class="std std-ref">Supported Types</span></a>). Following are the examples of plans with type hints:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">typing</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span><span class="p">,</span> <span class="n">Optional</span>

<span class="k">def</span> <span class="nf">plan_demo3a</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="c1"># Type of &#39;detector&#39; not defined, therefore Queue Server will find and attempt to</span>
    <span class="c1">#   replace all strings passed to this parameter by references to objects in</span>
    <span class="c1">#   RE Worker namespace. Specifying a type hint for the ``detector`` parameter</span>
    <span class="c1">#   will disable the automatic string conversion.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>

<span class="k">def</span> <span class="nf">plan_demo3b</span><span class="p">(</span><span class="n">positions</span><span class="p">:</span> <span class="n">typing</span><span class="o">.</span><span class="n">Union</span><span class="p">[</span><span class="n">typing</span><span class="o">.</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># Explicitly using the &#39;typing&#39; module. Setting default value to &#39;None&#39;.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>

<span class="k">def</span> <span class="nf">plan_demo3c</span><span class="p">(</span><span class="n">positions</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="c1"># This example is precisely identical to the previous example. Both hints are</span>
    <span class="c1">#   converted to &#39;typing.Union[typing.List[float], NoneType]&#39; and</span>
    <span class="c1">#   correctly processed by the Queue Server.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="defining-default-values-in-plan-header">
<h2>Defining Default Values in Plan Header<a class="headerlink" href="#defining-default-values-in-plan-header" title="Permalink to this headline">¶</a></h2>
<p>Follow Python syntax guidelines for defining default values. The type of
the default value must be supported by the Queue Server (see <a class="reference internal" href="#supported-types"><span class="std std-ref">Supported Types</span></a>).
If the default value must have type, which is not supported, override the default
value in <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the default value is defined in the <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code>,
Queue Server ignores the default value defined in the header. A default value
in the header is <strong>required</strong> if the default value is defined in the decorator.</p>
</div>
</div>
<div class="section" id="parameter-descriptions-in-docstring">
<h2>Parameter Descriptions in Docstring<a class="headerlink" href="#parameter-descriptions-in-docstring" title="Permalink to this headline">¶</a></h2>
<p>Queue Server will collect text descriptions of the plan and parameters from NumPy-style
docstrings. Type information specified in docstrings is ignored. The example below
shows a plan with a docstring:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">plan_demo4a</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">npts</span><span class="p">,</span> <span class="n">delay</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the description of the plan that could be passed</span>
<span class="sd">    to the client and displayed to users.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    detector : ophyd.Device</span>
<span class="sd">        The detector (Ophyd device). Space is REQUIRED before</span>
<span class="sd">        and after &#39;:&#39; that separates the parameter name and</span>
<span class="sd">        type. Type information is ignored.</span>
<span class="sd">    name</span>
<span class="sd">        Name of the experiment. Type is optional. Queue Server</span>
<span class="sd">        will still successfully process the docstring.</span>
<span class="sd">        Documenting types of all parameters is recommended</span>
<span class="sd">        practice.</span>
<span class="sd">    npts : int</span>
<span class="sd">        Number of experimental points.</span>
<span class="sd">    delay : float</span>
<span class="sd">        Dwell time.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="parameter-annotation-decorator">
<span id="id2"></span><h2>Parameter Annotation Decorator<a class="headerlink" href="#parameter-annotation-decorator" title="Permalink to this headline">¶</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code> allows to override any annotation item of the plan,
including text descriptions of the plan and parameters, parameter type annotations and
default values. The decorator can be used to define all annotation items of a plan, but
it is generally advised that it is used only when absolutely necessary.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>If the default value of a parameter is defined in the decorator, the parameter <strong>must</strong>
have a default value defined in the header. The default values in the decorator and
the header do not have to match. See the <a class="reference internal" href="#default-values-in-decorator"><span class="std std-ref">notes</span></a>
for the use case.</p>
</div>
<div class="section" id="plan-and-parameter-descriptions">
<h3>Plan and Parameter Descriptions<a class="headerlink" href="#plan-and-parameter-descriptions" title="Permalink to this headline">¶</a></h3>
<p>Text descriptions of plans and parameters are not used by Queue Server and do not
affect processing of plans. In some applications it may be desirable to have
different versions of text descriptions in plan documentation (e.g. technical description)
and in user interface (e.g. instructions on how to use plans remotely). The decorator
allows to override plan and/or parameter descriptions from the docstring. In this
case the descriptions defined in the decorator will be displayed to the user.</p>
<p>All parameters in <cite>parameter_annotation_decorator</cite> are optional. In the following
example, the description for the parameter <cite>npts</cite> is not overridden by the decorator:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">bluesky_queueserver</span> <span class="kn">import</span> <span class="n">parameter_annotation_decorator</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;description&quot;</span><span class="p">:</span> <span class="s2">&quot;Plan description displayed to users.&quot;</span><span class="p">,</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;detector&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;description&quot;</span><span class="p">:</span>
                <span class="s2">&quot;Description of the parameter &#39;detector&#39;</span><span class="se">\n</span><span class="s2">&quot;</span> \
                 <span class="s2">&quot;displayed to Queue Server users&quot;</span><span class="p">,</span>

        <span class="p">}</span>
        <span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;description&quot;</span><span class="p">:</span>
                <span class="s2">&quot;Description of the parameter &#39;name&#39;</span><span class="se">\n</span><span class="s2">&quot;</span> \
                <span class="s2">&quot;displayed to Queue Server users&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo4a</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">npts</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Plan description, which is part of documentation.</span>
<span class="sd">    It is not visible to Queue Server users.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    detector : ophyd.Device</span>
<span class="sd">        The detector. Technical description,</span>
<span class="sd">        not visible to Queue Server users.</span>
<span class="sd">    name</span>
<span class="sd">        Name of the experiment. Technical description,</span>
<span class="sd">        not visible to Queue Server users.</span>
<span class="sd">    npts : int</span>
<span class="sd">        Number of experimental points.</span>
<span class="sd">        Description remains visible to Queue Server users,</span>
<span class="sd">        because it is not overridden by the decorator.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
<div class="section" id="parameter-types">
<h3>Parameter Types<a class="headerlink" href="#parameter-types" title="Permalink to this headline">¶</a></h3>
<p>Parameter type hints defined in the plan header can be overridden in
<code class="docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code>. The type annotations defined in the decorator
do not influence execution of plans in Python. Overriding types should be avoided
whenever possible.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Types in the decorator must be represented as string literals. E.g. <code class="docutils literal notranslate"><span class="pre">&quot;str&quot;</span></code>
represents string type, <code class="docutils literal notranslate"><span class="pre">&quot;typing.List[int]&quot;</span></code> represents an array
of integers, etc. Module name <code class="docutils literal notranslate"><span class="pre">typing</span></code> must be explictly used when
defining generic types.</p>
</div>
<p>Type annotations defined in the decorator may be used to override unsupported type hints
in plan headers. But the main application of the decorator is to define custom enums
based on lists of names of plans and devices or string literals. Support for custom enums
is integrated in functionality of Queue Server, including type validation and string
conversion. If parameter type defined in the annotation includes custom enum type
based on plans or devices, all plan or device names passed to the parameter that match
the names used in type definition are converted to references to plans and devices in
RE Worker namespace. The lists of names of plans and devices or string literals may
also be used by client applications to generate user interfaces
(e.g. populate combo boxes for selecting device names).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
<span class="kn">from</span> <span class="nn">ophyd</span> <span class="kn">import</span> <span class="n">Device</span>
<span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span><span class="p">,</span> <span class="n">det4</span><span class="p">,</span> <span class="n">det5</span>
<span class="kn">from</span> <span class="nn">bluesky_queueserver</span> <span class="kn">import</span> <span class="n">parameter_annotation_decorator</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;detector&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1"># &#39;DetectorType1&#39; is the type name (should be a valid Python name)</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;DetectorType1&quot;</span><span class="p">,</span>
            <span class="c1"># &#39;DetectorType1&#39; is defined as custom enum with string values</span>
            <span class="c1">#   &#39;det1&#39;, &#39;det2&#39; and &#39;det3&#39;</span>
            <span class="s2">&quot;devices&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;DetectorType1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det2&quot;</span><span class="p">,</span> <span class="s2">&quot;det3&quot;</span><span class="p">]},</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo5a</span><span class="p">(</span><span class="n">detector</span><span class="p">,</span> <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="c1"># Type hint for the parameter &#39;detector&#39; in the header is not required.</span>
    <span class="c1"># Queue Server will accept the plan if &#39;detector&#39; parameter value is</span>
    <span class="c1">#   a string with values &#39;det1&#39;, &#39;det2&#39; or &#39;det3&#39;. The string will</span>
    <span class="c1">#   be replaced with the respective reference before the plan is executed.</span>
    <span class="c1">#   Plan validation will fail if the parameter value is not in the set.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;detectors&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1"># Note that type definition is a string !!!</span>
            <span class="c1"># Type names &#39;DetectorType1&#39; and &#39;DetectorType2&#39; are defined</span>
            <span class="c1">#   only for this parameter. The types with the same names</span>
            <span class="c1">#   may be defined differently for the other parameters</span>
            <span class="c1">#   of the plan if necessary, but doing so is not recommended.</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;typing.Union[typing.List[DetectorType1]&quot;</span> \
                          <span class="s2">&quot;typing.List[DetectorType2]]&quot;</span><span class="p">,</span>
            <span class="s2">&quot;devices&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;DetectorType1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det2&quot;</span><span class="p">,</span> <span class="s2">&quot;det3&quot;</span><span class="p">],</span>
                        <span class="s2">&quot;DetectorType2&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det4&quot;</span><span class="p">,</span> <span class="s2">&quot;det5&quot;</span><span class="p">]},</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo5b</span><span class="p">(</span><span class="n">detectors</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Device</span><span class="p">],</span> <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="c1"># Type hint contains correct Python type that will be passed to the parameter</span>
    <span class="c1">#   before execution.</span>
    <span class="c1"># Queue Server will accept the plan if &#39;detectors&#39; is a list of strings</span>
    <span class="c1">#   from any of the two sets. E.g. [&#39;det1&#39;, &#39;det3&#39;] or [&#39;det4&#39;, &#39;det5&#39;]</span>
    <span class="c1">#   will be accepted but [&#39;det2&#39;, &#39;det4&#39;] will be rejected (because the</span>
    <span class="c1">#   detectors belong to different lists).</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Similar syntax may be used to define custom enums for plans (use <code class="docutils literal notranslate"><span class="pre">&quot;plans&quot;</span></code> dictionary key
instead of <code class="docutils literal notranslate"><span class="pre">&quot;devices&quot;</span></code>) or strings (use <code class="docutils literal notranslate"><span class="pre">&quot;enums&quot;</span></code> dictionary key). The strings listed
as <code class="docutils literal notranslate"><span class="pre">&quot;devices&quot;</span></code> are converted to references to devices and the strings listed as <code class="docutils literal notranslate"><span class="pre">&quot;plans&quot;</span></code>
are converted to references to plans before plan execution. Strings listed under <code class="docutils literal notranslate"><span class="pre">&quot;enums&quot;</span></code>
are not converted to references, but still used for plan parameter validation.
Mixing devices, plans and enums in one type definition is possible (Queue Server will handle
the types correctly), but not recommended.</p>
<p>The decorator supports three built-in enum types: <code class="docutils literal notranslate"><span class="pre">AllDetectors</span></code>, <code class="docutils literal notranslate"><span class="pre">AllMotors</span></code> and <code class="docutils literal notranslate"><span class="pre">AllFlyers</span></code>.
The built-in enum types should not be defined in the parameter annotation. The enums
include lists of all detectors (readable devices), all motors (readable and writable devices) or
all flyers (flyable devices) from the namespace. Explicitly defining those types in the annotation
for a parameter overrides the default behavior (only for one plan parameter).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span><span class="p">,</span> <span class="n">det4</span>
<span class="kn">from</span> <span class="nn">bluesky_queueserver</span> <span class="kn">import</span> <span class="n">parameter_annotation_decorator</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;detectors&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="c1"># &#39;AllDetectors&#39; is the built-in enum type. All detectors (readable</span>
            <span class="c1">#   devices) from the namespace will be automatically included</span>
            <span class="c1">#   in the list (&#39;det1&#39;, &#39;det2&#39;, &#39;det3&#39; and &#39;det4&#39;).</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;typing.List[AllDetectors]&quot;</span><span class="p">,</span>
            <span class="c1"># Explicitly defining the type &#39;AllDetectors&#39; will override</span>
            <span class="c1">#   the default behavior (only for this parameter).</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo5c</span><span class="p">(</span><span class="n">detectors</span><span class="p">,</span> <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>Definitions of custom enums for devices or plans may include any devices from RE Worker
namespace. The definitions are included in representation of plans in the list of existing
plans. If built-in enum types are used, the definitions will contain full lists of
devices from the namespace. When lists of allowed plans are generated for user groups,
type definitions are filtered based on user group permissions, so that only the devices
and plans that are allowed for the user group remain. This allows to use entries
from downloaded lists of allowed plans for validation of plans and for generation of
user interfaces without verification user permissions, since it is guaranteed,
that the type definitions contain only devices and plans that the current user
is allowed to use. Filtering of type definitions may cause some lists to become empty
in case current user does not have permission to use any devices or plans that are
listed in type definition.</p>
</div>
<div class="section" id="default-values">
<span id="default-values-in-decorator"></span><h3>Default Values<a class="headerlink" href="#default-values" title="Permalink to this headline">¶</a></h3>
<p>Using decorator to override default values defined in plan header with different values
is possible, but generally not recommended unless absolutely necessary. Overriding the default
value is justified when the type of the default value defined in the header is not supported,
but the type of the default value defined in the decorator is supported
and passing this value with the plan submitted to the queue leads to the same
result as directly passing the default value defined in the header to the plan
(e.g. in IPython).</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The default value defined in the decorator must be represented as a string (as type
annotation). E.g. <code class="docutils literal notranslate"><span class="pre">&quot;10&quot;</span></code> represents integer value <code class="docutils literal notranslate"><span class="pre">10</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;'det1'&quot;</span></code> represents
the string value <code class="docutils literal notranslate"><span class="pre">'det1'</span></code> and <code class="docutils literal notranslate"><span class="pre">&quot;['det1',</span> <span class="pre">'det2']&quot;</span></code> represents an array of strings.</p>
</div>
<p>The following example illustrates the user case which requires overriding the default value.
In this example, the default value for the parameter <code class="docutils literal notranslate"><span class="pre">detector</span></code> is a reference to <code class="docutils literal notranslate"><span class="pre">det1</span></code>,
which has unsupported type. It is required that when the plan is submitted to Queue Server,
and no value for <code class="docutils literal notranslate"><span class="pre">detector</span></code> parameter is provided, then the string <code class="docutils literal notranslate"><span class="pre">&quot;det1&quot;</span></code> is used
as a default value, which is then substituted by reference to <code class="docutils literal notranslate"><span class="pre">det1</span></code>. The decorator
contains the definition of custom enum for supported device names and sets the default
value as a string representing the name of one of the supported devices.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">ophyd.sim</span> <span class="kn">import</span> <span class="n">det1</span><span class="p">,</span> <span class="n">det2</span><span class="p">,</span> <span class="n">det3</span>
<span class="kn">from</span> <span class="nn">bluesky_queueserver</span> <span class="kn">import</span> <span class="n">parameter_annotation_decorator</span>

<span class="nd">@parameter_annotation_decorator</span><span class="p">({</span>
    <span class="s2">&quot;parameters&quot;</span><span class="p">:</span> <span class="p">{</span>
        <span class="s2">&quot;detector&quot;</span><span class="p">:</span> <span class="p">{</span>
            <span class="s2">&quot;annotation&quot;</span><span class="p">:</span> <span class="s2">&quot;DetectorType1&quot;</span><span class="p">,</span>
            <span class="s2">&quot;devices&quot;</span><span class="p">:</span> <span class="p">{</span><span class="s2">&quot;DetectorType1&quot;</span><span class="p">:</span> <span class="p">[</span><span class="s2">&quot;det1&quot;</span><span class="p">,</span> <span class="s2">&quot;det2&quot;</span><span class="p">,</span> <span class="s2">&quot;det3&quot;</span><span class="p">]},</span>
            <span class="s2">&quot;default&quot;</span><span class="p">:</span> <span class="s2">&quot;&#39;det1&#39;&quot;</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">})</span>
<span class="k">def</span> <span class="nf">plan_demo6a</span><span class="p">(</span><span class="n">detector</span><span class="o">=</span><span class="n">det1</span><span class="p">,</span> <span class="n">npts</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="nb">float</span><span class="o">=</span><span class="mf">1.0</span><span class="p">):</span>
    <span class="c1"># The default value for the parameter &#39;detector&#39; is a reference to &#39;det1&#39;</span>
    <span class="c1">#   when the plan is started from IPython. If the plan is submitted to</span>
    <span class="c1">#   the queue and no value is provided for the parameter &#39;detector&#39;, then</span>
    <span class="c1">#   the parameter is going to be set to string literal value &#39;&quot;det1&quot;&#39;,</span>
    <span class="c1">#   which is then substituted with the reference to the detector &#39;det1&#39;</span>
    <span class="c1">#   before the plan is executed.</span>
    <span class="o">&lt;</span><span class="n">code</span> <span class="n">implementing</span> <span class="n">the</span> <span class="n">plan</span><span class="o">&gt;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="plan-annotation-api">
<span id="id3"></span><h2>Plan Annotation API<a class="headerlink" href="#plan-annotation-api" title="Permalink to this headline">¶</a></h2>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="generated/bluesky_queueserver.parameter_annotation_decorator.html#bluesky_queueserver.parameter_annotation_decorator" title="bluesky_queueserver.parameter_annotation_decorator"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parameter_annotation_decorator</span></code></a></p></td>
<td><p>The decorator allows to attach a custom description to a function or generator function.</p></td>
</tr>
</tbody>
</table>
</div>
</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="generated/bluesky_queueserver.parameter_annotation_decorator.html" class="btn btn-neutral float-right" title="bluesky_queueserver.parameter_annotation_decorator" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="generated/bluesky_queueserver.validate_plan.html" class="btn btn-neutral float-left" title="bluesky_queueserver.validate_plan" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2019-2021, Brookhaven National Laboratory.

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>